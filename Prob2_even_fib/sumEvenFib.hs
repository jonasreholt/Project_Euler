-- Each new term in the Fibonacci sequence is generated by adding
-- the previous two terms. By starting with 0 and 1.
-- Find the sum of all even Fibonacci that do not exceed 4 mil.

-- Hardcode versions
sumEvenFib :: Integer -> Integer -> Integer -> Integer
sumEvenFib max a b
    | b >= max   = 0
    | even b    = b + sumEvenFib max b (a+b)
    | odd b     = sumEvenFib max b (a+b)

-- Mathematical versions

-- the golden ratio
phi = (1 + sqrt 5) / 2
psi = 1 - phi

fib' :: Double -> Integer
fib' n = round ((phi ** n) / sqrt 5)

-- Claim: sum fib' i, i=0 to n = fib' (n+2) - 1.
-- Base case for n=0: fib ' 0 = 0 = 1 - 1
-- Inductive step:
--   fib' (n+3) - 1 = sum fib' i, i=0 to n+1
--   which is what we want, hence it must be true for all n
sumFib :: Double -> Integer
sumFib n =
    fib' (n+2) - 1

-- Every third F number is even, and F is defined as the sum of the two
-- preceding numbers. Hence we will have two uneven numbers (who's sum
-- is the same as the next even number). This will go on forever, meaning
-- the even sum is just sumFib n / 2, for all n giving a even fibonacci
-- number. Hence the below function only works if the n'th F number is even.
sumEvenFib' :: Double -> Double
sumEvenFib' n =
    (fromIntegral (sumFib n)) / 2

-- Finding the number n which is at most max
fibN :: Double -> Integer
fibN max =
    floor (logBase phi (max * sqrt 5 + 0.5))

-- Finding even sum of Fibonacci number not exceeding 4,000,000
-- Must find the largest even Fibonacci number closest to 4,000,000.
--   fibN grants n, now utilizing that every third Fibonacci number is
-- even, I say n - ( n `mod` 3) or
-- 3k <= n => 3 <= n/k => 3 = floor (n/k)
n = fibN (4*10**6)
answerToProb2 = sumEvenFib'' (fromIntegral (n - (n `mod` 3)))